import displayLogo from "./display-logo.png";
import mouseHover from "./mouse-hover.png";
import meshTransform from "./mesh-transform.png";
import noisePreview from "./4d-noise.png";

import Image from "next/image";

Hello world! To celebrate my new position at Basement.studio I created this
small experiment.

I'm gonna focus on the shader code. Feel free to check the complete source code on [Github](https://github.com/matiasngf/portfolio/tree/main/packages/experiments/shaders/basement-logo).

Lets start by showing the model into the scene.

```glsl
// Vertex Shader
varying vec3 vNormal;
varying vec2 vUv;
varying vec3 wPos;

void main() {
  vUv = uv;
  vNormal = normal;
  wPos = (modelMatrix * vec4(position, 1.0)).xyz;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(wPos, 1.0);
}
```

```glsl
// Fragment shader

varying vec3 vNormal;
varying vec2 vUv;
varying vec3 wPos;

void main() {
  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
}
```

<Image src={displayLogo} />

The first thing we need is a `mask` for our disolve effect. To solve this, I implemented a couple of `uniforms` that can be used to create a `circle mask`.

The uniforms are:

- `vec3 mousePosition`
- `float transitionSize`
- `float radius`

To create the mask I'm using this function:

```glsl
float getOffsetFactor(vec3 pos) {
  float x = length(pos - mousePosition) - radius;
  x = x / transitionSize;
  x = clamp(x, 0.0, 1.0);

  return x;
}
```

Let's visualize it:

```glsl
// Fragment shader

varying vec3 vNormal;
varying vec2 vUv;
varying vec3 wPos;

// Load our uniforms
uniform vec3 mousePosition;
uniform float transitionSize;
uniform float radius;

// utils
// getOffsetFactor...

void main() {

  float offsetFactor = getOffsetFactor(wPos);

  vec3 color = mix(
    vec3(1.0, 1.0, 1.0),
    vec3(1.0, 0.0, 0.0),
    offsetFactor
  );

  gl_FragColor = vec4(color, 1.0);
}
```

In red we can see the area that will be affected by the effect.

<Image src={mouseHover} />

Now that we have our mask, we can start working on the disolve effect. In order to "disolve" something a possible approach is to simply deform the object at the same time that we apply a noise textue to it. A cheap thanos effect.

### Transforming the mesh

On the `vertex shader`, we can calcualte the `offsetFactor` for each vertex and use it to **translate the `vertex` in the direction of the `normal`.**

```glsl
// Fragment shader

varying vec3 vNormal;
varying vec2 vUv;
varying vec3 wPos;

uniform vec3 mousePosition;
uniform float transitionSize;
uniform float radius;
uniform float offsetDistance;

// utils
// getOffsetFactor...

void main() {
  vUv = uv;
  vNormal = normal;

  // calcualte world position
  wPos = (modelMatrix * vec4(position, 1.0)).xyz;

  // calculate offset
  float offsetFactor = getOffsetFactor(wPos);
  vec3 offsetDirection = normalize(position - mousePosition);
  vec3 offset = normal * offsetFactor * offsetDistance;

  // transform pos with offset
  vec3 pos = position;
  pos += offset;

  // recalculate world pos after transform
  wPos = (modelMatrix * vec4(pos, 1.0)).xyz;

  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
}
```

Now, the vertices that are affected by the disolve effect are moving in the direction of the normal:

<Image src={meshTransform} />

### Applying the noise texture

To create a mask for the disolve effect we can use a noise texture. I used the [Simplex 4D Noise (by Ian McEwan, Ashima Arts)](https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83).

I also added a `noiseSize` uniform to control the scale of the noise texture.

```glsl
// Fragment shader

varying vec3 vNormal;
varying vec2 vUv;
varying vec3 wPos;

uniform float time;
uniform vec3 mousePosition;
uniform float transitionSize;
uniform float radius;
uniform float noiseSize;

// utils
// noise4d1...

void main() {
  // The noise takes a vec4 as parameter,
  // so we can use the time as the 4th dimension to animate it
  vec4 noiseParam = vec4(wPos / noiseSize, time * 0.5);

  // Generate the noise
  float noiseFactor = noise4d1(noiseParam);

  // Remap the noise to a range between 0 and 1
  noiseFactor = noiseFactor * 0.5 + 0.5;

  gl_FragColor = vec4(vec3(noiseFactor), 1.0);
}
```

<Image src={noisePreview} />
