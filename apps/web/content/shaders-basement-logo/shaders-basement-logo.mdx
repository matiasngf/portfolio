import displayLogo from "./display-logo.png";
import mouseHover from "./mouse-hover.png";

import Image from "next/image";

<center>
  Hello world! To celebrate my new position at Basement.studio I created this
  small experiment.
</center>

For this post. I'm gonna focus on the shader code. Feel free to check the complete source code on [Github](https://github.com/matiasngf/portfolio/tree/main/packages/experiments/shaders/basement-logo).

Lets start by showing the model into the scene.

```glsl
// Vertex Shader
varying vec3 vNormal;
varying vec2 vUv;
varying vec3 wPos;

void main() {
  vUv = uv;
  vNormal = normal;
  wPos = (modelMatrix * vec4(position, 1.0)).xyz;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(wPos, 1.0);
}
```

```glsl
// Fragment Shader
varying vec3 vNormal;
varying vec2 vUv;
varying vec3 wPos;

void main() {
  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
}
```

<Image src={displayLogo} />

The first thing we need is a `mask` for our disolve effect. To solve this, I implemented a couple of `uniforms` that can be used to create a `circle mask`.

The uniforms are:

- `vec3 mousePosition`
- `float transitionSize`
- `float radius`

To create the mask I'm using this function:

```glsl
float getOffsetFactor(vec3 pos) {
  float x = length(pos - mousePosition) - radius;
  x = x / transitionSize;
  x = clamp(x, 0.0, 1.0);

  return x;
}
```

Let's visualize it:

```glsl
// Fragment Shader
varying vec3 vNormal;
varying vec2 vUv;
varying vec3 wPos;

// Load our uniforms
uniform vec3 mousePosition;
uniform float transitionSize;
uniform float radius;

// inject util code
${getOffsetFactor}

void main() {

  float offsetFactor = getOffsetFactor(wPos);

  vec3 color = mix(
    vec3(0.0, 1.0, 1.0),
    vec3(1.0, 0.0, 0.0),
    offsetFactor
  );

  gl_FragColor = vec4(color, 1.0);
}
```

In red we can see the area that will be affected by the effect.

<Image src={mouseHover} />

Now that we have our mask, we can start working on the disolve effect. In order to "disolve" something a possible approach is to simply deform the object at the same time that we apply a noise textue to it. A cheap thanos effect.

### Transforming the mesh

On the vertex shader, we can calcualte the offsetFactor and use it to deform the mesh.

```glsl
varying vec3 vNormal;
varying vec2 vUv;
varying vec3 wPos;

uniform vec3 mousePosition;
uniform float transitionSize;
uniform float radius;
uniform float offsetDistance;

// inject util code
${getOffsetFactor}

void main() {
  vUv = uv;
  vNormal = normal;

  // calcualte world position
  wPos = (modelMatrix * vec4(position, 1.0)).xyz;

  // calculate offset
  float offsetFactor = getOffsetFactor(wPos);
  vec3 offsetDirection = normalize(position - mousePosition);
  vec3 offset = normal * offsetFactor * offsetDistance;

  // transform pos with offset
  vec3 pos = position;
  pos += offset;

  // recalculate world pos after transform
  wPos = (modelMatrix * vec4(pos, 1.0)).xyz;


  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
}
```
