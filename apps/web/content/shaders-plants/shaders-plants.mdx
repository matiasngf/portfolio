import { Source } from "@/components/mdx/source";

import stage from "./stage.png";
import debugBranches from "./debug-branches.png";

import cylinder1 from "./cylinder-1.png";
import cylinder2 from "./cylinder-2.png";
import cylinder3 from "./cylinder-3.png";

import cylinderTransform1 from "./cylinder-transform-1.png";
import cylinderTransform2 from "./cylinder-transform-2.png";
import cylinderTransform3 from "./cylinder-transform-3.png";
import cylinderTransform4 from "./cylinder-transform-4.png";
import cylinderTransform5 from "./cylinder-transform-5.png";
import cylinderTransform6 from "./cylinder-transform-6.png";
import pathVertexVars from "./path-vertex-vars.png";

import branchPath from "./branch-path.png";
import branchPathHalf from "./branch-path-half.png";

import branchletsDebug from "./branchlets-debug.png";

export const experimentPath =
  "https://github.com/matiasngf/portfolio/tree/main/packages/experiments/shaders/plants";

In this post, I wanted to experiment with how to create procedural branches and how to make them grow along a path.

## Objectives:

This is quite a large experiment that accomplishes multiple things:

- Making a mesh "grow" along a path drawn in Blender.
- Generating new branchlets procedurally that will expand from the main branch.
- Adding leaves that will grow along with the branchlets.
- Make everything react to the scroll.

## Getting the base model

To do this experiment. I used a base [plant model from sketchfab](https://sketchfab.com/3d-models/free-pothos-potted-plant-money-plant-e9832f38484f4f85b3f9081b51fa3799). Once I have the model in Blender, I deleted the default branches and added some Bezier Curves that will be used as guides later.

[imagen de Blender]

To correctly export and parse the model later, the curves were transformed into geometry and renamed using the format `Branch.[number]`. I also added one leaf and stick models that will be used later in the experiment.

Finally, the model was exported as `plant.glb`.

## Main setup

I'm using `zustand` and `leva` in order to create a store and controlls that will hold the state of the plant. The store will hold the following values:

- grow: number -> The amount of growth that the plant will have.
- debugCamera: boolean -> Whether to use an external camera and helpers.
- debugGrid: boolean -> Whether to show the debug lines or not.

<Source basePath={experimentPath} path="/src/utils/use-config.ts">

```ts
import { useControls } from "leva";
import { create } from "zustand";
import { shallow } from "zustand/shallow";

interface ConfigStore {
  grow: number;
  debugCamera: boolean;
  debugGrid: boolean;
}

export const useConfigStore = create<ConfigStore>(() => ({
  grow: 10,
  debugCamera: false,
  debugGrid: false,
}));

/** Should be used only once */
export const useConfigControls = () => {
  useControls(() => ({
    // disabled in prod
    grow: {
      value: 0,
      min: 0,
      max: 1.3,
      step: 0.001,
      onChange: (value) => {
        useConfigStore.setState({ grow: value });
      },
    },
    debugCamera: {
      value: false,
      onChange: (value) => {
        useConfigStore.setState({ debugCamera: value });
      },
    },
    debugGrid: {
      value: false,
      onChange: (value) => {
        useConfigStore.setState({ debugGrid: value });
      },
    },
  }));

  return;
};

export const useConfig = () => {
  return useConfigStore(
    (state) => ({
      grow: state.grow,
      debug: state.debug,
    }),
    shallow
  );
};
```

</Source>

Then, I created a main component that imports the Branches and Pot components and exports the `GLTF nodes` that will be used to parse the model.

<Source basePath={experimentPath} path="/src/Plant/index.tsx">

```tsx
import { LineSegments, Mesh } from "three";
import type { GLTF } from "three-stdlib";
import { Branches } from "./branches";
import { Pot } from "./pot";

export interface PlantGLTF extends GLTF {
  nodes: {
    pot: Mesh;
    stick: Mesh;
    Branch: LineSegments;
    leaf: Mesh;
  };
}

export const Plant = () => {
  return (
    <group position={[0, 0, 0]}>
      <Branches />
      <Pot />
    </group>
  );
};
```

</Source>

I also added a background stage to the scene:

<Image src={stage} />

## Creating the main branches

To add the branches into our scene. I first needed to parse the data of the `.glb` file. Because we transformed our Bezier curves into Meshes, the data will be stored as `LineSegments`.

```tsx
import { GLTFLoader } from "three-stdlib";
import { useLoader } from "@react-three/fiber";
import { PlantGLTF } from ".";

export const Branches = () => {
  // Load the model using the GLTFLoader
  const plantModel = useLoader(
    GLTFLoader,
    "/experiment-shaders-plants-assets/plant.glb"
  ) as unknown as PlantGLTF;

  // Parse the model and find the LineSegments nodes that start with "Branch"
  const branches = useMemo(() => {
    return Object.values(plantModel.nodes).filter(
      (node) => node.name.startsWith("Branch") && node.type === "LineSegments"
    ) as LineSegments[];
  }, [plantModel]);
};
```

Then I needed to add some uniforms that will be used by all the materials later. I also added a `useEffect` that will update the uniforms when the `grow` value changes.

```tsx
import { useEffect, useMemo } from "react";
import { Uniforms, useUniforms } from "../utils/uniforms";
import { useConfig } from "../utils/use-config";

// Create some default uniforms
const branchUniforms = {
  progress: 0,
  branchRadius: 0.005,
  branchGrowOffset: 0.1,
};

// Export the typed uniforms
export type BranchUniforms = Uniforms<typeof branchUniforms>;

export const Branches = () => {
  /** ...previous code... */

  // Add a hook to create uniforms
  const [uniforms, setUniforms] = useUniforms(branchUniforms);

  // Get the grow value from the store
  const { grow } = useConfig();

  // The grow value will be used to update the progress uniform
  useEffect(() => {
    setUniforms({
      progress: grow,
    });
  }, [grow]);
};
```

Fianlly, I mapped over the `branches` array and return a `<Branch />` component. This is the final source code:

<Source basePath={experimentPath} path="/src/Plant/branches.tsx">

```tsx
import { useLoader } from "@react-three/fiber";
import { GLTFLoader } from "three-stdlib";
import { PlantGLTF } from ".";
import { useEffect, useMemo } from "react";
import { LineSegments } from "three";
import { Uniforms, useUniforms } from "../utils/uniforms";
import { useConfig } from "../utils/use-config";
import { Branch } from "./branch";

const branchUniforms = {
  progress: 0,
  branchRadius: 0.005,
  branchGrowOffset: 0.1,
};

export type BranchUniforms = Uniforms<typeof branchUniforms>;

export const Branches = () => {
  const plantModel = useLoader(
    GLTFLoader,
    "/experiment-shaders-plants-assets/plant.glb"
  ) as unknown as PlantGLTF;

  const branches = useMemo(() => {
    return Object.values(plantModel.nodes).filter(
      (node) => node.name.startsWith("Branch") && node.type === "LineSegments"
    ) as LineSegments[];
  }, [plantModel]);

  const [uniforms, setUniforms] = useUniforms(branchUniforms);

  const { grow } = useConfig();

  useEffect(() => {
    setUniforms({
      progress: grow,
    });
  }, [grow]);

  return (
    <group>
      {branches.map((branch, i) => (
        <Branch uniforms={uniforms} segments={branch} key={i} branchlets={15} />
      ))}
    </group>
  );
};
```

</Source>

If we turn on the debug for the branches, we can see the path that they will follow:

<Image src={debugBranches} />

## The `<Branch/>` component

The `Branch` component will do two things. First, create a mesh that will grow along a `segments` path using the `uniforms.growFactor`, and second, add secondary procedural branches called `branchlets`.

First, lets create an interface for the component:

```ts
export interface BranchProps {
  segments: LineSegments;
  uniforms: BranchUniforms;
  branchlets: number;
}
```

Now we can start coding our component, first we can load the branch texture using the `useTexture` hook.

```tsx
export const Branch = ({ segments, uniforms, branchlets }: BranchProps) => {
  const branchMap = useTexture(
    "/experiment-shaders-plants-assets/branch-texture.jpg",
    (t: Texture) => {
      t.wrapT = RepeatWrapping;
      t.wrapS = MirroredRepeatWrapping;
    }
  );
};
```

I wanted to generate the mesh procedurally, so I created a `getBranchMesh` function that takes the `segments` path and the `uniforms` and returns a `branchMesh` and a `branchPath`.

```tsx
export const Branch = ({ segments, uniforms, branchlets }: BranchProps) => {
  const branchMap = useTexture(
    "/experiment-shaders-plants-assets/branch-texture.jpg",
    (t: Texture) => {
      t.wrapT = RepeatWrapping;
      t.wrapS = MirroredRepeatWrapping;
    }
  );

  const { branchMesh, branchPath } = useMemo(() => {
    return getBranchMesh(segments.clone(true), uniforms, branchMap);
  }, [segments, uniforms, branchMap]);

  return <primitive object={branchMesh} />;
};
```

_Let's go just one more step into this rabbit hole and see what the `getBranchMesh` function does._

### getBranchMesh

This function handles the generation of the branch mesh. But, this mesh needs to follow the path segments and even grow along it. To do this, I first needed to create a cylinder geometry that will be used as a base for the mesh.

<Source basePath={experimentPath} path="/src/Plant/helpers/get-branch-mesh.ts">

```tsx
/** Transform a lineSegment into a branch mesh */
export const getBranchMesh = (
  branch: LineSegments,
  branchUniforms: BranchUniforms,
  texture: Texture
) => {
  const branchResolution = 20;
  const noramlizedCylinder = new CylinderGeometry(
    1, // radiusTop
    1, // radiusBottom
    1, // height
    branchResolution, // radialSegments
    numVertices * 2 // heightSegments
  );
};
```

</Source>

This is the result of the cylinder geometry:

<Image src={cylinder1} />

And these are some example vertices coordinates of the geometry:

<Image src={cylinder2} />

The idea is to reposition this cylinder vertices along the path using a shader.

<Image src={cylinderTransform1} />

Let's take one of the vertices and see how it would be transformed and call it `p`:

<Image src={cylinder3} />

We now need to find where that `vertex` would land in the `path`. To imagine this let's first stretch the path to be a straight line:

<Image src={cylinderTransform2} />

Now we can see that the `p` point would land between the second and third point of the path. Let's call those points `i` and `j`:

<Image src={cylinderTransform3} />

Knowing what vertices are `i` and `j` (previous and next vertices), we can start transforming the `p` point. The first step is to flatten all the vertices of the cylinder geometry to the `xz` plane:

<Image src={cylinderTransform4} />

Then, the point `p` will be rotated to match the direction `j-i`.

<Image src={cylinderTransform5} />

Finally, we can `lerp` between the `i` and `j` points to find the final position of `p` and translate it:

<Image src={cylinderTransform6} />

At first, I only used the raw vertex data in the branch shader, but I found that it was not very efficient. So I decided to pre-calculate some values in javascript and pass them to the shader as uniforms.

### Growing meshes

I needed a way to efficiently transform the vertices of the cylinder geometry. To do this, I created a funciton that loops over each vertex of the `segments` variable, and calculates the following variables:

```ts
// position of this point
position: Vector3;
// distance form this point to the previous one
distance: number;
// direction from this point to the next
direction: Vector3;
// rotation from the prev point to this one
rotation: Quaternion;
// rotation from the first point to this one
addedQuaternion: Quaternion;
```

Here is a visual representation of the variables:

<Image src={pathVertexVars} />

_Note: The `addedQuaternion` is calcualted by multiplying all the rotations from the previous points._

I called this interface `PathVertex`. Then I also created `PathVertices` which also has the totalDistance calculated. To do this I created the `verticesFromLineSegment` function:

```ts
interface PathVertex {
  // position of this point
  position: Vector3;
  // distance form this point to the previous one
  distance: number;
  // direction from this point to the next
  direction: Vector3;
  // rotation from the prev point to this one
  rotation: Quaternion;
  // rotation from the first point to this one
  addedQuaternion: Quaternion;
}

interface PathVertices {
  pathVertices: PathVertex[];
  totalDistance: number;
  numVertices: number;
}

const verticesFromLineSegment = (branch: LineSegments): PathVertices => {...}
```

To see the complete implementation of this function, check the source code:

<Link
  target="_blank"
  href={experimentPath + "/src/Plant/helpers/path-vertex.ts"}
>
  /src/Plant/helpers/path-vertex.ts
</Link>

## Branch material

Lets recap what we have so far:

- We are creating a function called `getBranchMesh` that handles the creation of a cylinder geometry and the transformation of the vertices.
- We have a `segments` path that will be used to generate the branch mesh.
- We precalculated the `pathVertices` that will be used to transform the vertices of the mesh.

Now we can start creating the branch shader. First, we need to create a `shaderMaterial` that will be used by the mesh:

<Source basePath={experimentPath} path="/src/Plant/helpers/get-branch-mesh.ts">

```tsx
export const getBranchMesh = (
  branch: LineSegments,
  branchUniforms: BranchUniforms,
  texture: Texture
) => {
  const branchPath = verticesFromLineSegment(branch);

  const { pathVertices, totalDistance, numVertices } = branchPath;

  /** This material will transform the cylinder geometry to follow the path */
  const branchMaterial = new ShaderMaterial({
    name: branch.name + "material",
    vertexShader: branchVertexShader,
    fragmentShader: branchFragmentShader,
    glslVersion: GLSL3,
    defines: {
      NUM_VERTICES: numVertices,
    },
    uniforms: {
      map: { value: texture },
      pathVertices: {
        value: pathVertices,
      },
      totalDistance: { value: totalDistance },
      ...branchUniforms,
    },
  });

  const branchResolution = 20;
  const noramlizedCylinder = new CylinderGeometry(
    1,
    1,
    1,
    branchResolution,
    numVertices * 2
  );
  const branchMesh = new Mesh(noramlizedCylinder, branchMaterial);

  return {
    branchMesh,
    branchPath,
    position: branch.position,
    rotation: branch.rotation,
  };
};
```

</Source>

### Vertex shader

The key of the mesh transform is on the vertex shader. First, we need to create some basic structures that will be used later:

<Source basePath={experimentPath} path="/src/utils/shaders/paths.ts">

```glsl
struct PathVertex {
  vec3 position;
  float distance;
  vec3 direction;
  // quaternion rotation
  vec4 rotation;
  vec4 addedQuaternion;
};

struct PathPos {
  vec3 position;
  vec3 direction;
  vec4 rotation;
};
```

</Source>

Now, we need to define the uniforms.

<Source basePath={experimentPath} path="/src/utils/shaders/paths.ts">

```glsl
uniform PathVertex pathVertices[NUM_VERTICES];
uniform float totalDistance;
uniform float progress;
uniform float branchRadius;
uniform float branchGrowOffset;
```

</Source>

Then, some varyings that we will pass between the vertex and fragment shaders:

<Source basePath={experimentPath} path="/src/Plant/shaders/branch-shaders.ts">

```glsl
varying vec2 vUv;
varying vec3 worldPos;
varying vec3 localPos;
varying float targetFactor;
varying float growFactorRaw;
varying float growFactor; // clamped

```

</Source>

### getPositionOnPath helper

This function will calculate the position of a point on the path. It will take a `targetFactor` that will be a value between `0` and `1` and will return a `PathPos` with the position, direction, and rotation of the point.

<Source basePath={experimentPath} path="/src/utils/shaders/paths.ts">

```glsl
PathPos getPositionOnPath(float percentage) {

  percentage = clamp(percentage, 0.0, 1.0);

  // Calculate the target distance along the path
  float targetDistance = percentage * totalDistance;

  // Find the index of the vertices
  // indexPrev ------> iNext
  int iNext = 1;
  float traveledDistance = pathVertices[1].distance;
  while (traveledDistance < targetDistance) {
    if (iNext == NUM_VERTICES - 1) {
      // reached the end of the path
      break;
    }
    iNext++;
    traveledDistance += pathVertices[iNext].distance;
  }
  int iPrev = max(0, iNext - 1);

  // Get the two adjacent vertices
  vec3 posPrev = pathVertices[iPrev].position;
  vec3 posNext = pathVertices[iNext].position;

  float distancePrevToNext = pathVertices[iNext].distance;

  // Calculate the interpolation factor based on distances
  // 0 ------ tDist ------ offsetDist
  float offsetDist = traveledDistance - distancePrevToNext;
  float tDist = targetDistance - offsetDist;
  float t = tDist / distancePrevToNext;

  // Interpolate the position
  vec3 position = mix(posPrev, posNext, t);

  // Calculate the direction as the normalized direction between the two vertices
  vec3 direction = mix(pathVertices[iPrev].direction, pathVertices[iNext].direction, t);

  //mix quaterions
  vec4 rotation = mix(pathVertices[iPrev].addedQuaternion, pathVertices[iNext].addedQuaternion, t);

  return PathPos(
    position,
    direction,
    rotation
  );
}
```

</Source>

### Final vertex shader

This is the complete source of the vertex shader.

<Source basePath={experimentPath} path="/src/Plant/shaders/branch-shaders.ts">

```glsl
${pathStructs} // include of path structs

${pathUniforms} // include of uniforms

varying vec2 vUv;
varying vec3 worldPos;
varying vec3 localPos;
varying float targetFactor;
varying float growFactorRaw;
varying float growFactor; // clamped

${rotate} // include of some rotation helpers
${getPositionOnPath} // include of path helper

float getGrowFactor(float p) {
  float totalLenght = totalDistance * p;
  float currentLenght = localPos.y * totalLenght;
  float growEnd = totalLenght - branchGrowOffset;

  float growFactor = (growEnd - currentLenght) / branchGrowOffset + 1.;
  return growFactor;
}

void main() {
  float clampedProgress = clamp(progress, 0.0, 1.0);
  localPos = position + vec3(0.0, 0.5, 0.0);
  targetFactor = localPos.y;

  // calculate grow factor
  growFactorRaw = getGrowFactor(clampedProgress);
  growFactor = clamp(growFactorRaw, 0.0, 1.0);
  float branchSize = branchRadius * growFactor;

  // move vertices to y = 0
  vec3 targetPos = position * vec3(branchSize, 0.0, branchSize);

  //translate to path

  // rotate the Y axis to the direction
  targetPos = qtransform(pathPosition.rotation, targetPos);

  // move to pos
  targetPos += pathPosition.position;


  vUv = uv;
  worldPos = (modelMatrix * vec4(targetPos, 1.0)).xyz;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(targetPos, 1.0);
}
```

</Source>

Let's break down some of the operations that are happening in the shader:

<div className="-space-y-2">

```glsl
// Get position on path
PathPos pathPosition = getPositionOnPath(targetFactor * clampedProgress);
```

<Image src={cylinderTransform3} />
</div>

<div className="-space-y-2">

```glsl
// Flatten cylinder to xz plane and scale to branchSize
vec3 targetPos = position * vec3(branchSize, 0.0, branchSize);
```

<Image src={cylinderTransform4} />
</div>

<div className="-space-y-2">

```glsl
// rotate the Y axis to the direction of the
// segment where the vertex should land
targetPos = qtransform(pathPosition.rotation, targetPos);
```

<Image src={cylinderTransform5} />
</div>

<div className="-space-y-2">

```glsl
// translate
targetPos += pathPosition.position;
```

<Image src={cylinderTransform6} />
</div>

The result of this shader is a mesh that will grow along the path:

<Image src={branchPath} />

If we set the `grow` uniform to 0.5, the branch will be translated to the middle of the path:

<Image src={branchPathHalf} />

## Branchlets

<Image src={branchletsDebug} />

Branchlets are secondary branches that will grow from the main branch. I didn't want to model each branchlet in Blender, so I decided to generate them procedurally.
